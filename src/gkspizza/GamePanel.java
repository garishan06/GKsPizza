/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package gkspizza;

import gkspizza.characters.NPC;
import gkspizza.characters.Chef;
import gkspizza.appliances.*;

import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.ArrayList;
import javax.imageio.ImageIO;
import java.awt.Color;
import java.awt.Font;

/**
 *
 * @author gari9870
 * @date Jan 12, 2024
 * @filename GamePanel
 * @description This class controls and displays our game
 */
public class GamePanel extends javax.swing.JPanel implements Runnable {

    //these variables are used to initiate and run the game loop
    private Thread gameThread;
    private boolean running = false;
    private final int FPS = 60;

    //game states
    private int gameState;
    private final int PLAYSTATE = 1;
    private final int PAUSESTATE = 2;
    private final int INTERACTSTATE = 3;
    //GUI components
    private GameFrame main;
    private PauseMenuPanel panPauseMenu;

    //Images
    private BufferedImage mapImage;

    //Important Game Objects
    private Chef chef;
    private ArrayList<NPC> customers;

    private Stove stove;
    private SaucingStation stnSauce;
    private ToppingStation stnTopping;
    private FrontCounter ctrFront;

    /**
     * This method is the constructor for the game panel. It is used to
     * initialize all the required game Objects.
     *
     * @param main represents the JFrame that game panel is run on
     */
    public GamePanel(GameFrame main) {
        initComponents();

        this.chef = new Chef(100, 600);
        this.customers = new ArrayList();
        spawnCustomer();
        this.stove = new Stove(225, 465, 90, 65, this);
        this.stnSauce = new SaucingStation(372, 465, 53, 30, this);
        this.stnTopping = new ToppingStation(90, 465, 90, 60, this);
        this.ctrFront = new FrontCounter(450, 642, 40, 70, this);

        loadImages();

        this.main = main; // this is the parent component

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        gameStopButton = new javax.swing.JButton();

        setBackground(new java.awt.Color(255, 204, 204));
        setMaximumSize(new java.awt.Dimension(820, 800));
        setMinimumSize(new java.awt.Dimension(820, 800));
        setPreferredSize(new java.awt.Dimension(820, 800));
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                formKeyReleased(evt);
            }
        });

        gameStopButton.setFont(new java.awt.Font("Rockwell Condensed", 0, 18)); // NOI18N
        gameStopButton.setText("Pause");
        gameStopButton.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 3));
        gameStopButton.setMaximumSize(new java.awt.Dimension(50, 40));
        gameStopButton.setMinimumSize(new java.awt.Dimension(50, 40));
        gameStopButton.setPreferredSize(new java.awt.Dimension(50, 40));
        gameStopButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                gameStopButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(677, Short.MAX_VALUE)
                .addComponent(gameStopButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(93, 93, 93))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(gameStopButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(754, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed

        //these key presses ensure the chef can move and interact with objects using WASD and enter
        switch (evt.getKeyCode()) {
            case KeyEvent.VK_W: //moving up
                if (this.getGameState() == this.PLAYSTATE) { // this ensures the chef doesn't move while the game is paused and while it is interacting with another object
                    this.getChef().move(4);
                    this.getChef().setWalkingState(true);
                }
                break;
            case KeyEvent.VK_S: // moving down
                if (this.getGameState() == this.PLAYSTATE) {
                    this.getChef().move(3);
                    this.getChef().setWalkingState(true);
                }
                break;
            case KeyEvent.VK_A: // moving left
                if (this.getGameState() == this.PLAYSTATE) {
                    this.getChef().move(1);
                    this.getChef().setWalkingState(true);
                }
                break;
            case KeyEvent.VK_D: // moving right
                if (this.getGameState() == this.PLAYSTATE) {
                    this.getChef().move(2);
                    this.getChef().setWalkingState(true);
                }
                break;
            case KeyEvent.VK_ENTER: // interacting with objects
                if (this.getGameState() == this.PLAYSTATE && interactCheck() != null) {
                    this.getChef().setWalkingState(false);
                    this.gameState = this.INTERACTSTATE;
                    interactCheck().interact();

                }

                break;
        }
    }//GEN-LAST:event_formKeyPressed

    private void formKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyReleased
        // if one of the keys are released, this likely means the character has stopped walking. This code will ensure its walking animation gets switched back to the idle animation instead.
        getChef().setWalkingState(false);
    }//GEN-LAST:event_formKeyReleased

    private void gameStopButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_gameStopButtonActionPerformed
        //opens up a PauseMenu Panel.
        if (this.getGameState() == this.PLAYSTATE) {
            this.pause();
        }

    }//GEN-LAST:event_gameStopButtonActionPerformed

//METHODS RELEVANT TO GAME LOOP AND RUNNING CODE
    /**
     * This method initiates the game and game loop variables.
     */
    public void startGameThread() {

        this.gameThread = new Thread(this);

        this.gameThread.start();
        this.running = true;
        this.gameState = this.PLAYSTATE;
    }

    /**
     * This method ends the game loop permanently.
     */
    public void stopGameThread() {
        this.running = false;

        try {
            this.gameThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    /**
     * This method is used to pause the game loop and open a pause screen, where
     * the user has options to return to the home screen or continue playing.
     */
    public void pause() {
        this.gameState = this.PAUSESTATE;

        this.panPauseMenu = new PauseMenuPanel(this);
        this.add(this.getPanPauseMenu());
        this.validate();

        this.getPanPauseMenu().setSize(this.getPanPauseMenu().getPreferredSize());
        this.getPanPauseMenu().setLocation(this.getWidth() / 2 - this.getPanPauseMenu().getWidth() / 2, this.getHeight() / 2 - this.getPanPauseMenu().getHeight() / 2);
        this.getPanPauseMenu().setVisible(true);

    }

    /**
     * This method is used to close the GamePanel when the user decides to quit
     * the game.
     */
    public void quit() {
        stopGameThread();

        this.getMain().quitGame();
        this.setVisible(false);

    }

    /**
     * This method is used to continue the game, after the user decides to pause
     * the game.
     */
    public void unpause() {
        if (this.getGameState() == this.PAUSESTATE) {
            this.gameState = this.PLAYSTATE;
            this.remove(this.getPanPauseMenu());
            this.requestFocus();
        }

    }

//GETTERS AND SETTERS    
    /**
     * This method is used to set the game's state
     *
     * @param state represents the different possible game states. The main
     * three being PLAYSTATE, where the game is fully running, PAUSESTATE, where
     * the game is temporarily paused, and INTERACTSTATE, where the user is
     * still in the game but interacting with an appliance.
     */
    public void setGameState(String state) {
        switch (state) {
            case "PLAY STATE":
                this.gameState = this.PLAYSTATE;
                break;
            case "INTERACT STATE":
                this.gameState = this.INTERACTSTATE;
                break;
        }
    }

    /**
     *
     * @return the game state
     */
    public int getGameState() {
        return this.gameState;
    }

    /**
     * @return the chef game object
     */
    public Chef getChef() {
        return chef;
    }

    /**
     * @return the arrayList storing all NPCS currently in the game.
     */
    public ArrayList<NPC> getCustomers() {
        return customers;
    }

//CUSTOMER METHODS
    /**
     * This method spawns new customers in. We set a limit on this method so
     * that only one customer can be in the store at a time.
     */
    private void spawnCustomer() {
        if (this.getCustomers().size() < 1) {
            this.getCustomers().add(new NPC(1000, 600));

        }

    }

    /**
     * This method removes customers from the store after they receive their
     * order and move off the screen
     */
    private void removeCustomer() {
        if (!this.customers.isEmpty()) {
            for (NPC customer : this.getCustomers()) {
                if (customer.getX() >= 900 && customer.getOrderState() == 3) {
                    this.getCustomers().remove(customer);
                    break;
                }

            }
        }
    }

    /**
     * This method moves all the customers in the customers array
     */
    private void moveCustomers() {
        if (!this.customers.isEmpty()) {
            for (NPC customer : this.getCustomers()) {
                customer.move();
            }
        }
    }

    /**
     * This method draws all the customers in the customers array
     */
    private void drawCustomers(Graphics2D g2) {
        if (!this.customers.isEmpty()) {
            for (NPC customer : this.getCustomers()) {
                customer.draw(g2);
            }
        }
    }

//IMPORTANT GAME LOOP METHODS
    /**
     * This method controls the game loop, and is programmed to ensure the game
     * runs at 60FPS
     */
    @Override
    public void run() {
        this.requestFocus();
        double drawInterval = 1000000000 / FPS;
        double delta = 0;
        long lastTime = System.nanoTime();
        long currentTime;
        long timer = 0;

        while (this.gameThread != null && this.running) { // this will run forever until the panel is closed

            currentTime = System.nanoTime();

            delta += (currentTime - lastTime) / drawInterval;
            timer += (currentTime - lastTime);
            lastTime = currentTime;

            if (delta >= 1) { // all methods in this if statement will get called 60 times per second
                this.update();
                repaint();
                delta--;
            }

        }
    }

    /**
     * This method continually updates and checks important game variables and
     * conditions. It also executes all important game functions and only runs
     * while the game is not paused.
     */
    private void update() {
        if (this.getGameState() != this.PAUSESTATE) {
            removeCustomer();
            spawnCustomer();
            moveCustomers();
            interactCheck();
        }
    }

    /**
     * This method is the primary draw method, and is used to draw all game
     * objects, images, and text. Unlike the update method, this method is not
     * affected by the pause state and instead, when paused, will keep redrawing
     * the same screen.
     *
     * @param g is a basic painting tool. It is used to create a more
     * sophisticated and efficient painting tool from the Graphics2D class,
     * "g2".
     */
    private void draw(Graphics g) {

        Graphics2D g2 = (Graphics2D) g;

        g2.drawImage(this.mapImage, 0, 0, this.mapImage.getWidth(), this.mapImage.getHeight(), null);
        getChef().draw(g2);
        drawCustomers(g2);

        if (interactCheck() != null) { //shows text when the player can interact with an appliance
            g2.setColor(Color.white);
            g2.setFont(new Font("Rockwell Condensed", 0, 36));
            g2.drawString("PRESS ENTER KEY TO INTERACT", 220, 170);
        }

    }

    /**
     * This method is used to load any important images. It is primarily used in
     * this class to load the panel's background image.
     */
    private void loadImages() {
        try {
            mapImage = ImageIO.read(getClass().getResourceAsStream("/images/screens/map.png"));
        } catch (IOException e) {

        }
    }

    /**
     * This method is used to check for any collisions that take place between
     * the chef and other appliances
     */
    private Appliance interactCheck() {

        if (this.getChef().getBounds().intersects(this.stove.getBounds())) {
            return stove;
        } else if (this.getChef().getBounds().intersects(this.stnSauce.getBounds())) {
            return stnSauce;
        } else if (this.getChef().getBounds().intersects(this.stnTopping.getBounds())) {
            return stnTopping;
        } else if (this.getChef().getBounds().intersects(this.ctrFront.getBounds())) {
            return ctrFront;
        }

        return null;
    }

    /**
     * paintComponent happens on object creation and when any changes occur to
     * the frame (size change, new objects added. etc.)
     *
     * @param g is a basic painting tool. It is used to create a more
     * sophisticated and efficient painting tool from the Graphics2D class,
     * "g2".
     */
    @Override // this means that we are replacing the old
    //method that is prebuilt with a new one.
    public void paintComponent(Graphics g) {
        super.paintComponent(g); //calls the old paintComponent method
        draw(g);//calls the draw method
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton gameStopButton;
    // End of variables declaration//GEN-END:variables

    /**
     * @return the pause menu panel
     */
    public PauseMenuPanel getPanPauseMenu() {
        return panPauseMenu;
    }

    /**
     * @return the game frame, the panel's parent container / component
     */
    public GameFrame getMain() {
        return main;
    }

}
